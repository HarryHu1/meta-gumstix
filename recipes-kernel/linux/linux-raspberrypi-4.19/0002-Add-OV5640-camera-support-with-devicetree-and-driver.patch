From d532080f88ed91a9878a967ef8fc5de89efe6aa5 Mon Sep 17 00:00:00 2001
From: Jay Zhao <jay.zhao@gumstix.com>
Date: Tue, 24 Apr 2018 14:35:16 -0700
Subject: [PATCH 2/2] Add OV5640 camera support with devicetree and driver

Signed-off-by: Jay Zhao <jay.zhao@gumstix.com>
---
 arch/arm/boot/dts/overlays/Makefile                |   3 +-
 .../boot/dts/overlays/ov5640-gumstix-overlay.dts   | 110 +++++++++++++++++++++
 drivers/media/i2c/ov5640.c                         |  24 ++++-
 3 files changed, 132 insertions(+), 5 deletions(-)
 create mode 100644 arch/arm/boot/dts/overlays/ov5640-gumstix-overlay.dts

diff --git a/arch/arm/boot/dts/overlays/Makefile b/arch/arm/boot/dts/overlays/Makefile
index 5439afd..180f8b3 100644
--- a/arch/arm/boot/dts/overlays/Makefile
+++ b/arch/arm/boot/dts/overlays/Makefile
@@ -132,7 +132,8 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
 	vga666.dtbo \
 	w1-gpio.dtbo \
 	w1-gpio-pullup.dtbo \
-	wittypi.dtbo
+	wittypi.dtbo \
+	ov5640-gumstix.dtbo
 
 targets += dtbs dtbs_install
 targets += $(dtbo-y)
diff --git a/arch/arm/boot/dts/overlays/ov5640-gumstix-overlay.dts b/arch/arm/boot/dts/overlays/ov5640-gumstix-overlay.dts
new file mode 100644
index 0000000..9a593ad
--- /dev/null
+++ b/arch/arm/boot/dts/overlays/ov5640-gumstix-overlay.dts
@@ -0,0 +1,110 @@
+// Definitions for OV5640 camera module on VC I2C bus
+/dts-v1/;
+/plugin/;
+#include <dt-bindings/power/raspberrypi-power.h>
+#include <dt-bindings/clock/bcm2835.h>
+/{
+	compatible = "brcm,bcm2708";
+
+	fragment@0 {
+		target = <&soc>;
+		__overlay__ {
+			csi0: csi0@7e800000 {
+				compatible = "brcm,bcm2835-unicam";
+				reg = <0x7e800000 0x800>,
+				      <0x7e802000 0x4>;
+				interrupts = <2 6>;
+				clocks = <&clocks BCM2835_CLOCK_CAM0>;
+				clock-names = "lp";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				#clock-cells = <1>;
+
+				status = "disabled";
+			};
+
+			csi1: csi1@7e801000 {
+				compatible = "brcm,bcm2835-unicam";
+				reg = <0x7e801000 0x800>,
+				      <0x7e802004 0x4>;
+				interrupts = <2 7>;
+				clocks = <&clocks BCM2835_CLOCK_CAM1>;
+				clock-names = "lp";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				#clock-cells = <1>;
+
+				status = "disabled";
+				power-domains = <&power RPI_POWER_DOMAIN_UNICAM1>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&i2c0>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+			ov5640: ov5640@3c {
+				compatible = "ovti,ov5640";
+				reg = <0x3c>;
+				status = "okay";
+
+				pinctrl-names = "default";
+				pinctrl-0 = <&ov5640_default>;
+
+				powerdown-gpios = <&gpio 17 0>;
+				reset-gpios = <&gpio 16 1>;
+				clock-names = "xclk";
+				clocks = <&clocks 40>; //40 is BCM2835_CLOCK_GP2
+				clock-frequency = <24000000>;
+
+				port {
+					ov5640_0: endpoint {
+						remote-endpoint = <&csi1_ep>;
+						clock-lanes = <0>;
+						data-lanes = <1 2>;
+						clock-continuous;
+						link-frequencies =
+							/bits/ 64 <297000000>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&csi1>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				csi1_ep: endpoint {
+					clock-lanes = <0>;
+					data-lanes = <1 2>;
+					remote-endpoint = <&ov5640_0>;
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&gpio>;
+		__overlay__ {
+			ov5640_default: pinmux_ov5640_default {
+				brcm,pins = <
+				6
+				16 /* gpio16.reset-gpios */
+				17 /* gpio17.powerdown-gpios */
+				>;
+				brcm,function = <4 0 0>;
+				brcm,pull = <0 2 1>;
+			};
+		};
+	};
+};
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index 39a2269..819020d 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -221,7 +221,6 @@ static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
  */
 
 static const struct reg_value ov5640_init_setting_30fps_VGA[] = {
-
 	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 5}, {0x3008, 0x42, 0, 0},
 	{0x3103, 0x03, 0, 0}, {0x3017, 0x00, 0, 0}, {0x3018, 0x00, 0, 0},
 	{0x3034, 0x18, 0, 0}, {0x3035, 0x14, 0, 0}, {0x3036, 0x38, 0, 0},
@@ -311,7 +310,7 @@ static const struct reg_value ov5640_init_setting_30fps_VGA[] = {
 
 static const struct reg_value ov5640_setting_30fps_VGA_640_480[] = {
 
-	{0x3035, 0x14, 0, 0}, {0x3036, 0x38, 0, 0}, {0x3c07, 0x08, 0, 0},
+	{0x3035, 0x11, 0, 0}, {0x3036, 0x38, 0, 0}, {0x3c07, 0x08, 0, 0},
 	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
 	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
 	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
@@ -328,7 +327,7 @@ static const struct reg_value ov5640_setting_30fps_VGA_640_480[] = {
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x4713, 0x03, 0, 0},
 	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x3503, 0x00, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0x83, 0, 0}, {0x3503, 0x00, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_15fps_VGA_640_480[] = {
@@ -567,7 +566,7 @@ static const struct reg_value ov5640_setting_15fps_PAL_720_576[] = {
 
 static const struct reg_value ov5640_setting_30fps_720P_1280_720[] = {
 	{0x3008, 0x42, 0, 0},
-	{0x3035, 0x21, 0, 0}, {0x3036, 0x54, 0, 0}, {0x3c07, 0x07, 0, 0},
+	{0x3035, 0x11, 0, 0}, {0x3036, 0x54, 0, 0}, {0x3c07, 0x07, 0, 0},
 	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
 	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
 	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
@@ -2208,6 +2207,7 @@ static int ov5640_probe(struct i2c_client *client,
 	struct device *dev = &client->dev;
 	struct fwnode_handle *endpoint;
 	struct ov5640_dev *sensor;
+	u32 xclk_freq;
 	int ret;
 
 	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
@@ -2254,7 +2254,23 @@ static int ov5640_probe(struct i2c_client *client,
 		return PTR_ERR(sensor->xclk);
 	}
 
+
+	ret = of_property_read_u32(dev->of_node, "clock-frequency", &xclk_freq);
+	if (ret) {
+		dev_err(dev, "could not get xclk frequency\n");
+		return ret;
+	}
+
 	sensor->xclk_freq = clk_get_rate(sensor->xclk);
+	dev_err(dev, "Check before xclk is: %d Hz\n", sensor->xclk_freq);
+	ret = clk_set_rate(sensor->xclk, xclk_freq);
+	if (ret) {
+		dev_err(dev, "could not set xclk frequency\n");
+		return ret;
+	}
+	sensor->xclk_freq = clk_get_rate(sensor->xclk);
+	dev_err(dev, "Check after xclk is: %d Hz\n", sensor->xclk_freq);
+
 	if (sensor->xclk_freq < OV5640_XCLK_MIN ||
 	    sensor->xclk_freq > OV5640_XCLK_MAX) {
 		dev_err(dev, "xclk frequency out of range: %d Hz\n",
-- 
2.7.4

